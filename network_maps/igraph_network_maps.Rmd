---
title: "igraph_network_maps"
author: "Natalie Samuels"
date: "2/17/2019"
output: html_document
---

Ojective: Convert network edge list dataframess to igraph plots

```{r load packages}

library(gplots)
library(rgexf)
library(stringr)
library(tidyr)
library(dplyr)

```


STEP 1: Create igraph object attributes

1a) Create edge dataframe containing "source" and "target" for each edge.
```{r create edges}

fun.create_edges = function(df.network_edge_list) 
{
  # rename 'PID' to 'source' and 'Nominations' to 'target'
  df.edges = df.network_edge_list %>% 
    rename(source = PID) %>% 
    rename(target = Nominations) %>% 
    select(source, target)
  
  return(df.edges)
}

```


1b) Create node dataframe containing "id"s for each node.
```{r create nodes}

fun.create_nodes = function(df.network_edge_list) 
{
  # get unique PIDs and rename to ids
  df.unique_sources = df.network_edge_list %>% 
    select(PID) %>% 
    unique() %>% 
    rename(id = PID)

  # get unique Nominations and rename to ids
  df.unique_targets = df.network_edge_list %>% 
    select(Nominations) %>% 
    unique() %>% 
    rename(id = Nominations)

  # combine all possible ids and extract unique
  df.possible_ids = rbind(df.unique_sources, df.unique_targets)
    df.unique_ids = df.possible_ids %>% 
    unique()
  
  df.nodes = df.unique_ids
  
  return(df.nodes)
}

```


1c) Add size info (based on in-degree) for each node to node dataframe
```{r node size}

fun.add_node_size = function(df.edges, df.nodes) 
{
  # create graph object
  g.network = graph_from_data_frame(df.edges, directed = TRUE, vertices = NULL)
  
  # calculate in-degree for PIDs (note that vector elements are named by PID)
  v.in_degree = degree(g.network, 
                      v = V(g.network), 
                      mode = c("in"), 
                      loops = FALSE, 
                      normalized = FALSE)
  
  # assign in-degree to each node
  df.nodes['in_degree'] = v.in_degree[match(df.nodes$id, names(v.in_degree))]
  
  # acquire and return in-degree column as vector
  return(df.nodes)
}

```


STEP 2: Create network plots

2a) Plotting function
```{r create plot}

fun.create_plot = function(df.network_edge_list, plot_title) 
{
  # create edge data frame
  df.edges = fun.create_edges(df.network_edge_list)
  
  # create node data frame
  df.nodes = fun.create_nodes(df.network_edge_list) 
  df.nodes = fun.add_node_size(df.edges, df.nodes) 
  
  # create igraph object
  g.network = graph_from_data_frame(d = df.edges, vertices = df.nodes, 
                                    directed = TRUE)
  g.network = simplify(g.network, remove.multiple = TRUE, remove.loops = TRUE) 
  
  #grab in-degree for vertex size
  in_degree = V(g.network)$in_degree
  
  plot(g.network, 
       # edge attributes
       edge.arrow.size = .1, edge.color = 'grey50', 
       arrow.mode = 3,
       # node attributes
       vertex.label = NA, vertex.color = 'blue', 
       vertex.size = in_degree+2, 
       # other attributes
       main = plot_title, layout = layout_with_fr)
}

```


2b) Prepare network names
```{r network_names}

fun.network_names = function(edge_list_dataframes) 
{
  v.network_names = names(edge_list_dataframes)
  
  v.network_names = gsub("CloseFrds", "Close Friends Network", v.network_names)
  v.network_names = gsub("EmpSupp", "Empathy Network", v.network_names)
  v.network_names = gsub("Gossip", "Gossip Network", v.network_names)
  v.network_names = gsub("Liked", "Popular Network", v.network_names)
  v.network_names = gsub("NegAffPres", "Feel Bad Network", v.network_names)
  v.network_names = gsub("NegEmoSupp", "Bad News Network", v.network_names)
  v.network_names = gsub("Persuasive", "Persuasive Network", v.network_names)
  v.network_names = gsub("PosAffPres", "Feel Good Network", v.network_names)
  v.network_names = gsub("PosEmoSupp", "Good News Network", v.network_names)
  v.network_names = gsub("Responsive", "Support Network", v.network_names)
  v.network_names = gsub("SocAdvice", "Advice Network", v.network_names)
  v.network_names = gsub("SpendTime", "Time Spent Network", v.network_names)
  
  return(v.network_names)
}

```


2c) Create individual plot PDFs
```{r individual plot pdfs}

fun.write_indiv_plot_pdf = function(edge_list_dataframes) 
{
  # prepare list of network names
  v.network_names = fun.network_names(edge_list_dataframes) 

  for (i in 1:length(edge_list_dataframes)) {
    df.network_edge_list = edge_list_dataframes[[i]]
    network_name = v.network_names[[i]]
    
    # remove spaces from network_name for saving
    file_name = gsub(' ', '_', network_name)
    path_name = paste('individual_network_plots/', file_name, '.pdf')
    
    # write plot to pdf
    pdf(path_name)
    fun.create_plot(df.network_edge_list, plot_title = network_name) 
    dev.off()
  }
  
}

```


2d) Create aggregate plot PDFs
```{r aggregate plot pdfs}

fun.write_agg_plot_pdf = function(edge_list_dataframes) 
{
  # prepare list of network names
  v.network_names = fun.network_names(edge_list_dataframes) 
  
  # get unique dorm names and count
  v.dorm_names = v.network_names %>% 
    str_extract(., "\\S+") %>% 
    unique() %>% 
    gsub('&', ' &\n', .)
  
  dorm_name_count = length(v.dorm_names)
  
  # get unique network_types and count
  v.network_types = str_match(v.network_names, "\\s(.+)")[,2]
  v.network_types = v.network_types %>% 
    unique() %>% 
    gsub(' ', '\n', .)
  
  network_type_count = length(v.network_types)
  
  # prepare output PDF
  path_name = 'network_plot_grid/all_network_plots.pdf'
  pdf(path_name, 
      width = dorm_name_count*8, height = network_type_count*8)
  
  # arrange plots in rows by network type and columns by dorm (+1 for headers)
  par(mfcol = c(network_type_count+1, dorm_name_count+1))

  # create network type column
  textplot(' ')
  
  for (i in 1:network_type_count) {
    row_name = v.network_types[[i]]
    textplot(row_name, cex = 10)
  }
  
  # create dorm columns
  for (i in 1:dorm_name_count) {
    column_name = v.dorm_names[[i]]
    textplot(column_name, cex = 10)
    
    for (j in 1:(network_type_count)) {
      df.network_edge_list = edge_list_dataframes[[j + (i-1)*network_type_count]]
      
      fun.create_plot(df.network_edge_list, plot_title = NULL) 
    }
  }
  
  dev.off()
}

```

